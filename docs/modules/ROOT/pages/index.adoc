= Quarkus Messaginghub Pooled JMS

include::./includes/attributes.adoc[]

:extension-status: stable

Quarkus extension for a JMS Connection pool and transaction manager integration for messaging applications supporting JMS 1.1 and 2.0 clients.

== Installation

If you want to use this extension, you need to add the `io.quarkiverse.messaginghub:quarkus-pooled-jms` extension first.
In your `pom.xml` file, add:

[source,xml,subs="+attributes"]
----
<dependency>
    <groupId>io.quarkiverse.messaginghub</groupId>
    <artifactId>quarkus-pooled-jms</artifactId>
    <version>{project-version}</version>
</dependency>
----

== Pooling support
It is enabled by default. And we test for `quarkus-artemis` and `quarkus-qpid-jms`
[NOTE]
====
`clientID` and `durableSubscriptionName` are not supported in pooling connections. If `setClientID` is called on a `reused` connection from the pool, an `IllegalStateException` will be thrown. You will get some error messages such like `Cause: setClientID can only be called directly after the connection is created`
====

== XA transaction support
It needs to add `quarkus-narayana-jta` extension:
[source,xml]
----
<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-narayana-jta</artifactId>
</dependency>
----
and add the following configuration to your `application.properties`:
[source,properties]
----
quarkus.pooled-jms.transaction=xa
quarkus.transaction-manager.enable-recovery=true
----
XA support is only available with `quarkus-artemis-jms`.

=== Consuming Messages with XA Transactions

When consuming messages with XA transactions enabled, it's important to understand how transaction boundaries work.

==== Synchronous Message Consumption (Recommended)

For reliable transaction management, use synchronous message consumption within a `@Transactional` method:

[source,java]
----
@Transactional
public void processMessages(ConnectionFactory connectionFactory) {
    try (JMSContext context = connectionFactory.createContext(Session.SESSION_TRANSACTED);
         JMSConsumer consumer = context.createConsumer(context.createQueue("myQueue"))) {
        
        Message message = consumer.receive(1000L);
        if (message != null) {
            // Process message
            // If an exception is thrown, the transaction will be rolled back
            // and the message will be redelivered
        }
    }
}
----

[IMPORTANT]
====
When using XA transactions, always create the `JMSContext` with `Session.SESSION_TRANSACTED` mode, not `JMSContext.AUTO_ACKNOWLEDGE`. The `AUTO_ACKNOWLEDGE` mode bypasses transaction control and messages will be acknowledged immediately.
====

==== Asynchronous Message Consumption (Advanced)

Using `MessageListener` with `setMessageListener()` for asynchronous message consumption requires special consideration:

[source,java]
----
// This pattern does NOT automatically participate in XA transactions!
@ApplicationScoped
public class MyListener implements MessageListener {
    
    @Inject
    public MyListener(ConnectionFactory connectionFactory) {
        JMSContext context = connectionFactory.createContext(JMSContext.AUTO_ACKNOWLEDGE);
        JMSConsumer consumer = context.createConsumer(context.createQueue("myQueue"));
        consumer.setMessageListener(this);
    }
    
    @Override
    public void onMessage(Message message) {
        // This callback runs on a JMS provider thread
        // There is NO automatic transaction boundary here
        // Exceptions thrown here will NOT roll back XA transactions
        throw new RuntimeException("Message not processed"); 
        // With AUTO_ACKNOWLEDGE, the message is already acknowledged and will be lost
    }
}
----

[WARNING]
====
The `MessageListener.onMessage()` callback is invoked on an internal JMS provider thread and **does not run within a transaction boundary** by default. When an exception is thrown:

* The message will be acknowledged (if using AUTO_ACKNOWLEDGE)
* No XA transaction rollback will occur
* The message will NOT be redelivered or sent to the Dead Letter Queue (DLQ)
* The message is effectively lost

This is a fundamental limitation of the JMS specification when using MessageListener directly.
====

If you need asynchronous message consumption with XA transaction support, consider these alternatives:

1. **Use Quarkus Messaging with Artemis JCA**: The `quarkus-artemis-jms-ra` extension provides proper Message-Driven Bean support with automatic transaction management around message listeners.

2. **Manual Transaction Management**: Manually manage transactions within the listener:
+
[source,java]
----
@ApplicationScoped
public class MyListener implements MessageListener {
    
    @Inject
    TransactionManager transactionManager;
    
    @Override
    public void onMessage(Message message) {
        try {
            transactionManager.begin();
            // Process message
            transactionManager.commit();
        } catch (Exception e) {
            try {
                transactionManager.rollback();
            } catch (Exception rbEx) {
                // Handle rollback exception
            }
            // Note: Manual session management may still be required
            // for proper message redelivery
        }
    }
}
----
+
[NOTE]
====
Even with manual transaction management, proper message redelivery requires careful session acknowledgement handling. For production use, consider using a JCA-based solution like `quarkus-artemis-jms-ra`.
====

3. **Polling Pattern**: Use a scheduled method to poll for messages synchronously within a transaction:
+
[source,java]
----
@ApplicationScoped
public class MessagePoller {
    
    @Inject
    ConnectionFactory connectionFactory;
    
    @Scheduled(every = "1s")
    @Transactional
    public void pollMessages() {
        try (JMSContext context = connectionFactory.createContext(Session.SESSION_TRANSACTED);
             JMSConsumer consumer = context.createConsumer(context.createQueue("myQueue"))) {
            
            Message message = consumer.receiveNoWait();
            if (message != null) {
                // Process message
                // Transaction will be rolled back on exception
            }
        }
    }
}
----

== Custom ConnectionFactory
For those messaging drivers which do not have quarkus extension, such as `ibmmq-client`. You need to create a custom `ConnectionFactory` and wrap it by yourself. Here is an example:
[source,java]
----
@Produces
public ConnectionFactory createXAConnectionFactory(PooledJmsWrapper wrapper) {
    MQXAConnectionFactory mq = new MQXAConnectionFactory();
    try {
        mq.setHostName(ConfigProvider.getConfig().getValue("ibm.mq.host", String.class));
        mq.setPort(ConfigProvider.getConfig().getValue("ibm.mq.port", Integer.class));
        mq.setChannel(ConfigProvider.getConfig().getValue("ibm.mq.channel", String.class));
        mq.setQueueManager(ConfigProvider.getConfig().getValue("ibm.mq.queueManagerName", String.class));
        mq.setTransportType(WMQConstants.WMQ_CM_CLIENT);
        mq.setStringProperty(WMQConstants.USERID,
            ConfigProvider.getConfig().getValue("ibm.mq.user", String.class));
        mq.setStringProperty(WMQConstants.PASSWORD,
            ConfigProvider.getConfig().getValue("ibm.mq.password", String.class));
    } catch (Exception e) {
        throw new RuntimeException("Unable to create new IBM MQ connection factory", e);
    }
    return wrapper.wrapConnectionFactory(mq);
}
----
[NOTE]
====
If you use `ibmmq-client` to consume messages and enable XA, you should make sure it is running in a transaction. Otherwise, you will get an error like `MQRC_SYNCPOINT_NOT_AVAILABLE`.
When you are using `ibmmq-client` and rollback a transaction, there will be a WARN message like:
[source]
----
WARN  [com.arj.ats.jta] (executor-thread-1) ARJUNA016045: attempted rollback of < formatId=131077, gtrid_length=35, bqual_length=36, tx_uid=0:ffffc0a86510:aed3:650915d7:16, node_name=quarkus, branch_uid=0:ffffc0a86510:aed3:650915d7:1f, subordinatenodename=null, eis_name=0 > (com.ibm.mq.jmqi.JmqiXAResource@79786dde) failed with exception code XAException.XAER_NOTA: javax.transaction.xa.XAException: The method 'xa_rollback' has failed with errorCode '-4'.
----
it may be ignored and can be assumed that MQ has discarded the transaction's work.
====

== Local JMS Transaction support
It needs to set the following configuration:
[source, properties]
----
quarkus.pooled-jms.transaction=enabled
----
and if it is running in a transaction, it can mark the session with `SESSION_TRANSACTED` and commit or rollback the session according to the outcome of the globe transaction. The example like sending message:
[source,java]
----
@Transactional
protected void send(String body, ConnectionFactory factory, String queueName) {
    try (JMSContext context = factory.createContext()) {
        JMSProducer producer = context.createProducer();
        producer.send(ActiveMQDestination.createQueue(queueName), body);

        log.info("send {}", body);
    }
}
----
[NOTE]
====
It is different from the XA support. So if there is any issue happening during the session committing, the transaction will not be rollbacked.
====

[[extension-configuration-reference]]
== Extension Configuration Reference

include::includes/quarkus-pooled-jms.adoc[leveloffset=+1, opts=optional]
